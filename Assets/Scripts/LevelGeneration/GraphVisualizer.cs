using UnityEngine;

namespace LevelGeneration
{
    /// <summary>
    /// Visualizer to visualize the graph created during level creation, this should only be used in debugging mode.
    /// Note: Before using, please destroy the parent object in the scene view.
    /// Manually.
    /// </summary>
    public static class GraphVisualizer 
    {
        private const int Segments = 50;
        private const float Radius = 0.1f;
        private static GameObject _parentObject;
        private static readonly int Color1 = Shader.PropertyToID("_Color");

        /// <summary>
        /// Visualize the graph on the scene view. Using simple node and vertex.
        /// </summary>
        /// <param name="roomGraph">The graph to be visualized.</param>
        public static void DrawGraph(RoomGraph roomGraph)
        {
            _parentObject = GameObject.Find("CirclesParent"); // Check if it already exists
            if (_parentObject == null)
            {
                _parentObject = new GameObject("CirclesParent"); // Create only if needed
            }
            // Always traverse the graph from the starting room.
            roomGraph.Traverse(Vector2Int.zero, new BreadthFirstTraversal(), VisualizeGraph);
        }
        
        /// <summary>
        /// Create the visual representation of the graph.
        /// </summary>
        /// <param name="node">The node to be visualized.</param>
        private static void VisualizeGraph(RoomNode node)
        {
            GenerateCircle(new Vector3(node.Position.x, node.Position.y, 0), GetNodeColor(node.RoomType));
        }

        /// <summary>
        /// This is black magic generated by ChatGPT, I don't really understand it, but for this use case we don't really need to.
        /// </summary>
        /// <param name="position">The position to spawn the circle in</param>
        /// <param name="color">The color of the visualized node</param>
        private static void GenerateCircle(Vector3 position, Color color)
        {
            var circle = new GameObject("Circle")
            {
                transform =
                {
                    position = position,
                    parent = _parentObject.transform
                }
            };

            var meshFilter = circle.AddComponent<MeshFilter>();
            var meshRenderer = circle.AddComponent<MeshRenderer>();

            Material material = new Material(Shader.Find("Sprites/Default"));
            // OR another very basic shader option:
            // Material material = new Material(Shader.Find("Unlit/Color"));
    
            // Force apply the color directly
            material.SetColor(Color1, color);
            meshRenderer.sharedMaterial = material;

            var mesh = new Mesh();
            var vertices = new Vector3[Segments + 1];
            int[] triangles = new int[Segments * 3];

            vertices[0] = Vector3.zero; // Center point
            float angleStep = 2 * Mathf.PI / Segments;

            for (int i = 1; i <= Segments; i++)
            {
                float angle = i * angleStep;
                vertices[i] = new Vector3(Mathf.Cos(angle) * Radius, Mathf.Sin(angle) * Radius, 0);
            }

            for (int i = 0; i < Segments; i++)
            {
                triangles[i * 3] = 0;
                triangles[i * 3 + 1] = i + 1;
                triangles[i * 3 + 2] = (i + 1) % Segments + 1;
            }

            mesh.vertices = vertices;
            mesh.triangles = triangles;
            mesh.RecalculateNormals();
    
            meshFilter.mesh = mesh;
        }


        private static Color GetNodeColor(RoomType roomType)
        {
            return roomType switch
            {
                RoomType.Normal => Color.white,
                RoomType.Boss => Color.red,
                RoomType.Merchant => Color.green,
                RoomType.Treasure => Color.yellow,
                RoomType.Start => Color.blue,
                _ => Color.magenta
            };
        }
    }
}
